#!/usr/bin/env python2
# -*- coding:utf-8 -*-
"""
shaozx@gmail.com 2009-10-08

用拼音补全命令行中的中文名称和路径

实验目录如下：
biff@lenovo:/domain/WorkSpace$ ls
SVN培训  全球眼  浙江建行  浙江农信

使用: (输完后按 TAB 键自动补全)
   cd S     <tab>             进入[SVN培训]
   cd q     <tab>             进入[全球眼]
   cd z     <tab>             自动补全[浙江]
   cd zj    <tab><tab>        提示[浙江建行 浙江农信]备选
   cd 浙江j <tab>             进入[浙江建行]
   cd zjj   <tab>             进入[浙江建行]
   cd zj1   <tab>             进入[浙江建行]
   cd zj2   <tab>             进入[浙江农信]

  2009-05-08修订  取不到拼音的汉字匹配任何字符
  2009-05-07新增  名称中有中文全角,可以用英文符号补全
  2009-05-06修订  解决数字序号定位时借位的问题
  2009-08-30新增  增加多音字支持，比如“音乐”
                  ((遇到有未被收入的多音字，请邮件联系我))
  2009-08-31新增  增加模糊拼音支持，比如'n'->'l'
                  ((需手工增加环境变量，配置方法见后面说明))

安装:
   直接执行 sh install.sh 进行安装;

如需模糊拼音支持，在系统环境变量中增加匹配的列表，对 n/l 进行模糊匹配
export CHSDIR="{ 'n':'l' }"
多个匹配对之间用逗号隔开：
export CHSDIR="{ 'n':'l','f':'p' }"


问题：
 1、多音字未解决,比如[浙江建行]要输入[zjjx]; ((已解决))
 2、大字符集输入使用变通的方法(取不到拼音的汉字匹配任何字符)

蔡国权/ 蔡依林/ 陈百强/ 陈楚生/ 陈慧琳/ 陈坤/   陈淑桦/ 成龙/
蔡琴/   草蜢/   陈柏宇/ 陈海铃/ 陈慧娴/ 陈倩倩/ 陈小春/
 如上,因为"蜢"和"倩"都是"?",[草蜢]无法用[cm]进入,只能用[c4]进入
 如果输入[cm<tab>],会提示[草蜢]和[陈倩倩],这时用[cm1]进入
 如果输入[cq<tab>],会提示[蔡琴][草蜢]和[陈倩倩]，同样用数字选择


祝Linux之行一路顺风!
有问题邮件联系!


"""


# [HACK]

# basic idea : match by pinyin acronym

# [1] for each subentries in current directory,
#  transform its basename by PinYin-Acronym:
# for example :  "银河英雄传说" ==> "yhyycs"

# [2] compare this pinyin-acronym with what user has input, if match, this
# subentry should be consider as one candidate for completion

import os
import sys
import locale

import table

DOUBLE_WIDTH = { u"～":u"~", u"！":u"!", u"＠":u"@", u"＃":u"#", u"＄":u"$",
        u"％":u"%", u"＆":u"&", u"＊":u"*", u"（":u"(", u"）":u")", u"＿":u"_",
        u"－":u"-", u"＋":u"+", u"［":u"[", u"］":u"]", u"＜":u"<", u"＞":u">",
        u"？":u"?", u"，":u",", u"。":u".", u"／":u"/", u"、":u"," }

# fuzzy pinyin
FUZZY = {}
try:
    FUZZY = eval( os.getenv("CHSDIR") )
    FUZZY.keys()
except StandardError:
    FUZZY = {}

def transform_double_width(uni_char):
    "transform double-width char into its single-width equivalent  "
    try :
        return DOUBLE_WIDTH[uni_char]
    except KeyError:
        return uni_char

def fuzzynize(pinyin):
    "fuzzy one pinyin to another"
    try :
        return FUZZY[pinyin]
    except KeyError:
        return pinyin

def get_pinyin_initials(uni_char):

    try:
        pinyin_initials = table.pinyin_initial[uni_char]
        return "".join(pinyin_initials)
    except KeyError:
        return uni_char

def acronymize(uni_char):
    "get single-byte acronym for one unicode char"

    # replace double-width chars with its single-width equivalents
    uni_char = transform_double_width(uni_char)
    # if ascii, return immediately
    if uni_char <  u"\x80" :
        return uni_char

    pinyin_initials = get_pinyin_initials(uni_char)

    # special case for chars having polyphone
    if len(pinyin_initials) > 1:
        return u"`%s`" % pinyin_initials

    # for most cases.
    return fuzzynize( pinyin_initials )

def get_acronym(string):
    "get acronym for unicode string"
    try:
        string = unicode(string,"utf-8")
    except UnicodeDecodeError:
        return string

    acronym = ""

    for char in string:
        acronym += acronymize(char)

    return acronym.encode("utf-8")


if __name__ == '__main__':

    # chsdir <dirattr> <already_input_part>
    if len(sys.argv) != 3 :
        sys.exit(1)

    dironly = sys.argv[1]
    path     = sys.argv[2].replace("\\","")

    # support fuzzy pinyin
    path = "".join( [ fuzzynize(x) for x in path] )

    index = None
    effective_path  = path
    # deal with special form such as  'xxx/cm1'
    if len(path) > 1 and '0' < path[-1] <= '9':
        index          = int(path[-1])
        effective_path = path[:-1]

    dirname            = os.path.dirname(path)
    basename           = os.path.basename(path)
    effective_basename = os.path.basename(effective_path)

    if not dirname :
        dirname = "./"

    # get all top-level subentries(non-recursive)
    try:
        entries = os.listdir(dirname)
    except OSError:
        sys.exit(0)

    # if an entry with the exact basename already exist, do nothing
    if basename in entries or effective_basename in entries :
        sys.exit(0)

    basename_acronym = get_acronym(effective_basename).replace("\\","")

    #print "basename acronym : %s" % basename_acronym

    reply = []

    for entry in entries:

        entry_acronym = get_acronym(entry).replace("\\","")

        # ignore entry which does not contain Chinese character.
        if entry_acronym == entry :
            continue

        i = j = 0

        while i < len(basename_acronym) and j < len(entry_acronym) :

            # dealing with polyphone
            if entry_acronym[j] == "`":
                end = entry_acronym.index("`", j+1)
                if entry_acronym.find( basename_acronym[i], j, end ) > 0 :
                    i += 1
                    j = end + 1
                    continue
            else:
                #if basename_acronym[i] == entry_acronym[j] or  entry_acronym[i] == "?":
                if ( basename_acronym[i] == entry_acronym[j] or
                     entry_acronym[i] == "?" or
                     basename_acronym[i] == "?" ):
                    i += 1
                    j += 1
                    continue

            if basename_acronym[i] != entry[i] :
                break

        # one match is found
        if i == len(basename_acronym)  :
            tmp = os.path.join(dirname, entry).replace("./", "")
            # if the caller is only interested with folders
            if dironly == "x-d" and not os.path.isdir(tmp):
                continue

            reply.append( tmp )

    try:
        locale.setlocale(locale.LC_ALL, "")
    except StandardError:
        pass

    reply.sort(key=locale.strxfrm)

    if index :
        try:
            print ( reply[index - 1] )
        except IndexError:
            # return the last candidate when index is out of range
            print ( reply[:-1])
    else:
        print ( "\n".join(reply) )

